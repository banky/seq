<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# seq

```go
import "github.com/banky/seq"
```

Package seq provides generic helpers for working with slices and other sequences. It includes functions for mapping, filtering, grouping, chunking, de\-duplicating, and computing aggregate values such as minima and maxima.

## Index

- [func Chunk\[T any\]\(slice \[\]T, size int\) \[\]\[\]T](<#Chunk>)
- [func Filter\[T any\]\(slice \[\]T, keep func\(T\) bool\) \[\]T](<#Filter>)
- [func Flatten\[T any\]\(slices \[\]\[\]T\) \[\]T](<#Flatten>)
- [func GroupBy\[T any, K comparable\]\(slice \[\]T, keyFunc func\(T\) K\) map\[K\]\[\]T](<#GroupBy>)
- [func LastIndex\[T comparable\]\(slice \[\]T, v T\) \(idx int, ok bool\)](<#LastIndex>)
- [func Map\[T any, R any\]\(slice \[\]T, f func\(T\) R\) \[\]R](<#Map>)
- [func MinMax\[T cmp.Ordered\]\(slice \[\]T\) \(min, max T\)](<#MinMax>)
- [func MinMaxFunc\[T any\]\(slice \[\]T, less func\(T, T\) int\) \(min, max T\)](<#MinMaxFunc>)
- [func Partition\[T any\]\(slice \[\]T, pred func\(T\) bool\) \(matches, nonMatches \[\]T\)](<#Partition>)
- [func Reduce\[T any, R any\]\(slice \[\]T, init R, f func\(R, T\) R\) R](<#Reduce>)
- [func Unique\[T comparable\]\(slice \[\]T\) \[\]T](<#Unique>)
- [func UniqueBy\[T any, K comparable\]\(slice \[\]T, keyFunc func\(T\) K\) \[\]T](<#UniqueBy>)


<a name="Chunk"></a>
## func [Chunk](<https://github.com/banky/seq/blob/main/seq.go#L221>)

```go
func Chunk[T any](slice []T, size int) [][]T
```

Chunk splits slice into consecutive sub\-slices of at most size elements. The final chunk may be smaller than size. The caller must ensure size \> 0.

Example:

```
values := []int{1, 2, 3, 4, 5}
chunks := Chunk(values, 2)
// chunks == [][]int{{1, 2}, {3, 4}, {5}}
```

<a name="Filter"></a>
## func [Filter](<https://github.com/banky/seq/blob/main/seq.go#L20>)

```go
func Filter[T any](slice []T, keep func(T) bool) []T
```

Filter returns a new slice containing only the elements of slice for which keep returns true.

Example:

```
numbers := []int{1, 2, 3, 4, 5, 6}
evens := Filter(numbers, func(n int) bool { return n%2 == 0 })
// evens == []int{2, 4, 6}
```

<a name="Flatten"></a>
## func [Flatten](<https://github.com/banky/seq/blob/main/seq.go#L145>)

```go
func Flatten[T any](slices [][]T) []T
```

Flatten returns a new slice containing all the elements of slices flattened into a single slice.

Example:

```
nested := [][]int{{1, 2}, {}, {3}, {4, 5}}
flat := Flatten(nested)
// flat == []int{1, 2, 3, 4, 5}
```

<a name="GroupBy"></a>
## func [GroupBy](<https://github.com/banky/seq/blob/main/seq.go#L127>)

```go
func GroupBy[T any, K comparable](slice []T, keyFunc func(T) K) map[K][]T
```

GroupBy groups the elements of slice into a map keyed by the value returned from keyFunc for each element.

Example:

```
words := []string{"a", "bb", "ccc", "dd"}
byLen := GroupBy(words, func(s string) int { return len(s) })
// byLen[1] == []string{"a"}
// byLen[2] == []string{"bb", "dd"}
// byLen[3] == []string{"ccc"}
```

<a name="LastIndex"></a>
## func [LastIndex](<https://github.com/banky/seq/blob/main/seq.go#L85>)

```go
func LastIndex[T comparable](slice []T, v T) (idx int, ok bool)
```

LastIndex returns the index of the last occurrence of v in slice. If v is not found, the returned index is \-1 and ok is false.

Example:

```
values := []string{"a", "b", "c", "b"}
idx, ok := LastIndex(values, "b")
// idx == 3, ok == true

_, ok = LastIndex(values, "z")
// ok == false
```

<a name="Map"></a>
## func [Map](<https://github.com/banky/seq/blob/main/seq.go#L40>)

```go
func Map[T any, R any](slice []T, f func(T) R) []R
```

Map returns a new slice containing the results of applying f to each element of slice.

Example:

```
numbers := []int{1, 2, 3}
strs := Map(numbers, func(n int) string {
	return fmt.Sprintf("n=%d", n)
})
// strs == []string{"n=1", "n=2", "n=3"}
```

<a name="MinMax"></a>
## func [MinMax](<https://github.com/banky/seq/blob/main/seq.go#L239>)

```go
func MinMax[T cmp.Ordered](slice []T) (min, max T)
```

MinMax returns the minimum and maximum values of slice. The caller must ensure that slice is non\-empty otherwise MinMax will panic.

Example:

```
values := []int{5, 2, 9, 1}
min, max := MinMax(values)
// min == 1
// max == 9
```

<a name="MinMaxFunc"></a>
## func [MinMaxFunc](<https://github.com/banky/seq/blob/main/seq.go#L268>)

```go
func MinMaxFunc[T any](slice []T, less func(T, T) int) (min, max T)
```

MinMaxFunc returns the minimum and maximum values of slice using the comparison function less. The comparison function should return a negative value if a \< b, zero if a == b, and a positive value if a \> b. The caller must ensure that slice is non\-empty otherwise MinMaxFunc will panic.

Example:

```
type Person struct {
	Name string
	Age  int
}

people := []Person{
	{Name: "Alice", Age: 30},
	{Name: "Bob", Age: 25},
	{Name: "Charlie", Age: 40},
}

lessByAge := func(a, b Person) int {
	return cmp.Compare(a.Age, b.Age)
}

min, max := MinMaxFunc(people, lessByAge)
// min == Person{Name: "Bob", Age: 25}
// max == Person{Name: "Charlie", Age: 40}
```

<a name="Partition"></a>
## func [Partition](<https://github.com/banky/seq/blob/main/seq.go#L103>)

```go
func Partition[T any](slice []T, pred func(T) bool) (matches, nonMatches []T)
```

Partition splits slice into two slices: matches, containing elements for which pred returns true, and nonMatches, containing the rest.

Example:

```
numbers := []int{1, 2, 3, 4, 5, 6}
evens, odds := Partition(numbers, func(n int) bool { return n%2 == 0 })
// evens == []int{2, 4, 6}
// odds  == []int{1, 3, 5}
```

<a name="Reduce"></a>
## func [Reduce](<https://github.com/banky/seq/blob/main/seq.go#L66>)

```go
func Reduce[T any, R any](slice []T, init R, f func(R, T) R) R
```

Reduce applies f to each element of slice, accumulating the result, and returns the final accumulated value. The accumulator is initialized with init.

Example \(sum\):

```
numbers := []int{1, 2, 3, 4}
sum := Reduce(numbers, 0, func(acc, n int) int {
	return acc + n
})
// sum == 10
```

Example \(concatenate\):

```
words := []string{"go", " ", "lang"}
joined := Reduce(words, "", func(acc, s string) string {
	return acc + s
})
// joined == "go lang"
```

<a name="Unique"></a>
## func [Unique](<https://github.com/banky/seq/blob/main/seq.go#L161>)

```go
func Unique[T comparable](slice []T) []T
```

Unique returns a new slice containing only the unique elements of slice. The order of first occurrence is preserved.

Example:

```
values := []int{1, 2, 1, 3, 2, 4, 4}
uniq := Unique(values)
// uniq == []int{1, 2, 3, 4}
```

<a name="UniqueBy"></a>
## func [UniqueBy](<https://github.com/banky/seq/blob/main/seq.go#L197>)

```go
func UniqueBy[T any, K comparable](slice []T, keyFunc func(T) K) []T
```

UniqueBy returns a new slice containing only the unique elements of slice, where uniqueness is determined by the key returned from keyFunc. The order of first occurrence \(by key\) is preserved.

Example:

```
type User struct {
	Name  string
	Email string
}

users := []User{
	{Name: "Alice", Email: "a@example.com"},
	{Name: "Bob", Email: "b@example.com"},
	{Name: "Alice Clone", Email: "a@example.com"},
}

uniqByEmail := UniqueBy(users, func(u User) string { return u.Email })
// uniqByEmail == []User{
//   {Name: "Alice", Email: "a@example.com"},
//   {Name: "Bob",   Email: "b@example.com"},
// }
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
